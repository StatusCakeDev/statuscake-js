/* tslint:disable */
/* eslint-disable */
/*
 * StatusCake API
 *
 * Copyright (c) 2023
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * API version: 1.2.0
 * Contact: support@statuscake.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

import * as runtime from '../runtime';
import {
  APIError,
  APIErrorFromJSON,
  APIErrorToJSON,
  APIResponse,
  APIResponseFromJSON,
  APIResponseToJSON,
  UptimeTestAlerts,
  UptimeTestAlertsFromJSON,
  UptimeTestAlertsToJSON,
  UptimeTestCheckRate,
  UptimeTestCheckRateFromJSON,
  UptimeTestCheckRateToJSON,
  UptimeTestHistory,
  UptimeTestHistoryFromJSON,
  UptimeTestHistoryToJSON,
  UptimeTestPeriods,
  UptimeTestPeriodsFromJSON,
  UptimeTestPeriodsToJSON,
  UptimeTestResponse,
  UptimeTestResponseFromJSON,
  UptimeTestResponseToJSON,
  UptimeTestType,
  UptimeTestTypeFromJSON,
  UptimeTestTypeToJSON,
  UptimeTests,
  UptimeTestsFromJSON,
  UptimeTestsToJSON,
} from '../models';

export interface CreateUptimeTestRequest {
  name: string;
  testType: UptimeTestType;
  websiteUrl: string;
  checkRate: UptimeTestCheckRate;
  basicUsername?: string;
  basicPassword?: string;
  confirmation?: number;
  contactGroups?: Array<string>;
  customHeader?: string;
  doNotFind?: boolean;
  dnsIps?: Array<string>;
  dnsServer?: string;
  enableSslAlert?: boolean;
  finalEndpoint?: string;
  findString?: string;
  followRedirects?: boolean;
  host?: string;
  includeHeader?: boolean;
  paused?: boolean;
  port?: number;
  postBody?: string;
  postRaw?: string;
  regions?: Array<string>;
  statusCodesCsv?: string;
  tags?: Array<string>;
  timeout?: number;
  triggerRate?: number;
  useJar?: boolean;
  userAgent?: string;
}

export interface DeleteUptimeTestRequest {
  testId: string;
}

export interface GetUptimeTestRequest {
  testId: string;
}

export interface ListUptimeTestAlertsRequest {
  testId: string;
  limit?: number;
  before?: number;
  after?: number;
}

export interface ListUptimeTestHistoryRequest {
  testId: string;
  limit?: number;
  before?: number;
  after?: number;
}

export interface ListUptimeTestPeriodsRequest {
  testId: string;
  limit?: number;
  before?: number;
  after?: number;
}

export interface ListUptimeTestsRequest {
  status?: ListUptimeTestsStatusEnum;
  page?: number;
  limit?: number;
  tags?: string;
  matchany?: boolean;
  nouptime?: boolean;
}

export interface UpdateUptimeTestRequest {
  testId: string;
  name?: string;
  websiteUrl?: string;
  checkRate?: UptimeTestCheckRate;
  basicUsername?: string;
  basicPassword?: string;
  confirmation?: number;
  contactGroups?: Array<string>;
  customHeader?: string;
  doNotFind?: boolean;
  dnsIps?: Array<string>;
  dnsServer?: string;
  enableSslAlert?: boolean;
  finalEndpoint?: string;
  findString?: string;
  followRedirects?: boolean;
  host?: string;
  includeHeader?: boolean;
  paused?: boolean;
  port?: number;
  postBody?: string;
  postRaw?: string;
  regions?: Array<string>;
  statusCodesCsv?: string;
  tags?: Array<string>;
  timeout?: number;
  triggerRate?: number;
  useJar?: boolean;
  userAgent?: string;
}

/**
 * UptimeApi - interface
 *
 * @export
 * @interface UptimeApiInterface
 */
export interface UptimeApiInterface {
  /**
   * Creates an uptime check with the given parameters.
   * @summary Create an uptime check
   * @param {string} name Name of the check
   * @param {UptimeTestType} testType
   * @param {string} websiteUrl URL or IP address of the server under test
   * @param {UptimeTestCheckRate} checkRate
   * @param {string} [basicUsername] Basic authentication username
   * @param {string} [basicPassword] Basic authentication password
   * @param {number} [confirmation] Number of confirmation servers to confirm downtime before an alert is triggered
   * @param {Array<string>} [contactGroups] List of contact group IDs
   * @param {string} [customHeader] JSON object. Represents headers to be sent when making requests
   * @param {boolean} [doNotFind] Whether to consider the check as down if the content is present within the response
   * @param {Array<string>} [dnsIps] List of IP addresses to compare against returned DNS records
   * @param {string} [dnsServer] FQDN or IP address of the nameserver to query
   * @param {boolean} [enableSslAlert] Whether to send an alert if the SSL certificate is soon to expire
   * @param {string} [finalEndpoint] Specify where the redirect chain should end
   * @param {string} [findString] String to look for within the response. Considered down if not found
   * @param {boolean} [followRedirects] Whether to follow redirects when testing. Disabled by default
   * @param {string} [host] Name of the hosting provider
   * @param {boolean} [includeHeader] Include header content in string match search
   * @param {boolean} [paused] Whether the check should be run
   * @param {number} [port] Destination port for TCP checks
   * @param {string} [postBody] JSON object. Payload submitted with the request. Setting this updates the check to use the HTTP POST verb
   * @param {string} [postRaw] Raw HTTP POST string to send to the server
   * @param {Array<string>} [regions] List of regions on which to run checks. The values required for this parameter can be retrieved from the &#x60;GET /v1/uptime-locations&#x60; endpoint.
   * @param {string} [statusCodesCsv] Comma separated list of status codes that trigger an alert
   * @param {Array<string>} [tags] List of tags
   * @param {number} [timeout] The number of seconds to wait to receive the first byte
   * @param {number} [triggerRate] The number of minutes to wait before sending an alert
   * @param {boolean} [useJar] Whether to enable cookie storage
   * @param {string} [userAgent] Custom user agent string set when testing
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UptimeApiInterface
   */
  createUptimeTestRaw(
    requestParameters: CreateUptimeTestRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<APIResponse>>;

  /**
   * Creates an uptime check with the given parameters.
   * Create an uptime check
   */
  createUptimeTest(
    requestParameters: CreateUptimeTestRequest,
    initOverrides?: RequestInit,
  ): Promise<APIResponse>;

  /**
   * Deletes an uptime check with the given id.
   * @summary Delete an uptime check
   * @param {string} testId Uptime check ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UptimeApiInterface
   */
  deleteUptimeTestRaw(
    requestParameters: DeleteUptimeTestRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>>;

  /**
   * Deletes an uptime check with the given id.
   * Delete an uptime check
   */
  deleteUptimeTest(
    requestParameters: DeleteUptimeTestRequest,
    initOverrides?: RequestInit,
  ): Promise<void>;

  /**
   * Returns an uptime check with the given id.
   * @summary Retrieve an uptime check
   * @param {string} testId Uptime check ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UptimeApiInterface
   */
  getUptimeTestRaw(
    requestParameters: GetUptimeTestRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<UptimeTestResponse>>;

  /**
   * Returns an uptime check with the given id.
   * Retrieve an uptime check
   */
  getUptimeTest(
    requestParameters: GetUptimeTestRequest,
    initOverrides?: RequestInit,
  ): Promise<UptimeTestResponse>;

  /**
   * Returns a list of uptime check alerts for a given id.  The returned results are a paginated series. Alongside the response data is a `links` object referencing the current response document, `self`, and the next page in the series, `next`.
   * @summary Get all uptime check alerts
   * @param {string} testId Uptime check ID
   * @param {number} [limit] The number of uptime alerts to return per page
   * @param {number} [before] Only alerts triggered before this UNIX timestamp will be returned
   * @param {number} [after] Only alerts triggered after this UNIX timestamp will be returned
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UptimeApiInterface
   */
  listUptimeTestAlertsRaw(
    requestParameters: ListUptimeTestAlertsRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<UptimeTestAlerts>>;

  /**
   * Returns a list of uptime check alerts for a given id.  The returned results are a paginated series. Alongside the response data is a `links` object referencing the current response document, `self`, and the next page in the series, `next`.
   * Get all uptime check alerts
   */
  listUptimeTestAlerts(
    requestParameters: ListUptimeTestAlertsRequest,
    initOverrides?: RequestInit,
  ): Promise<UptimeTestAlerts>;

  /**
   * Returns a list of uptime check history results for a given id, detailing the runs performed on the StatusCake testing infrastruture.  The returned results are a paginated series. Alongside the response data is a `links` object referencing the current response document, `self`, and the next page in the series, `next`.
   * @summary Get all uptime check history
   * @param {string} testId Uptime check ID
   * @param {number} [limit] The number of results to return per page
   * @param {number} [before] Only results created before this UNIX timestamp will be returned
   * @param {number} [after] Only results created after this UNIX timestamp will be returned
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UptimeApiInterface
   */
  listUptimeTestHistoryRaw(
    requestParameters: ListUptimeTestHistoryRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<UptimeTestHistory>>;

  /**
   * Returns a list of uptime check history results for a given id, detailing the runs performed on the StatusCake testing infrastruture.  The returned results are a paginated series. Alongside the response data is a `links` object referencing the current response document, `self`, and the next page in the series, `next`.
   * Get all uptime check history
   */
  listUptimeTestHistory(
    requestParameters: ListUptimeTestHistoryRequest,
    initOverrides?: RequestInit,
  ): Promise<UptimeTestHistory>;

  /**
   * Returns a list of uptime check periods for a given id, detailing the creation time of the period, when it ended and the duration.  The returned results are a paginated series. Alongside the response data is a `links` object referencing the current response document, `self`, and the next page in the series, `next`.
   * @summary Get all uptime check periods
   * @param {string} testId Uptime check ID
   * @param {number} [limit] The number of uptime check periods to return per page
   * @param {number} [before] Only check periods created before this UNIX timestamp will be returned
   * @param {number} [after] Only check periods created after this UNIX timestamp will be returned
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UptimeApiInterface
   */
  listUptimeTestPeriodsRaw(
    requestParameters: ListUptimeTestPeriodsRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<UptimeTestPeriods>>;

  /**
   * Returns a list of uptime check periods for a given id, detailing the creation time of the period, when it ended and the duration.  The returned results are a paginated series. Alongside the response data is a `links` object referencing the current response document, `self`, and the next page in the series, `next`.
   * Get all uptime check periods
   */
  listUptimeTestPeriods(
    requestParameters: ListUptimeTestPeriodsRequest,
    initOverrides?: RequestInit,
  ): Promise<UptimeTestPeriods>;

  /**
   * Returns a list of uptime checks for an account.
   * @summary Get all uptime checks
   * @param {'down' | 'up'} [status] Uptime check status
   * @param {number} [page] Page of results
   * @param {number} [limit] The number of uptime checks to return per page
   * @param {string} [tags] Comma separated list of tags assocaited with a check
   * @param {boolean} [matchany] Include uptime checks in response that match any specified tag or all tags
   * @param {boolean} [nouptime] Do not calculate uptime percentages for results
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UptimeApiInterface
   */
  listUptimeTestsRaw(
    requestParameters: ListUptimeTestsRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<UptimeTests>>;

  /**
   * Returns a list of uptime checks for an account.
   * Get all uptime checks
   */
  listUptimeTests(
    requestParameters: ListUptimeTestsRequest,
    initOverrides?: RequestInit,
  ): Promise<UptimeTests>;

  /**
   * Updates an uptime check with the given parameters.
   * @summary Update an uptime check
   * @param {string} testId Uptime check ID
   * @param {string} [name] Name of the check
   * @param {string} [websiteUrl] URL or IP address of the server under test
   * @param {UptimeTestCheckRate} [checkRate]
   * @param {string} [basicUsername] Basic authentication username
   * @param {string} [basicPassword] Basic authentication password
   * @param {number} [confirmation] Number of confirmation servers to confirm downtime before an alert is triggered
   * @param {Array<string>} [contactGroups] List of contact group IDs
   * @param {string} [customHeader] JSON object. Represents headers to be sent when making requests
   * @param {boolean} [doNotFind] Whether to consider the check as down if the content is present within the response
   * @param {Array<string>} [dnsIps] List of IP addresses to compare against returned DNS records
   * @param {string} [dnsServer] FQDN or IP address of the nameserver to query
   * @param {boolean} [enableSslAlert] Whether to send an alert if the SSL certificate is soon to expire
   * @param {string} [finalEndpoint] Specify where the redirect chain should end
   * @param {string} [findString] String to look for within the response. Considered down if not found
   * @param {boolean} [followRedirects] Whether to follow redirects when testing. Disabled by default
   * @param {string} [host] Name of the hosting provider
   * @param {boolean} [includeHeader] Include header content in string match search
   * @param {boolean} [paused] Whether the check should be run
   * @param {number} [port] Destination port for TCP checks
   * @param {string} [postBody] JSON object. Payload submitted with the request. Setting this updates the check to use the HTTP POST verb
   * @param {string} [postRaw] Raw HTTP POST string to send to the server
   * @param {Array<string>} [regions] List of regions on which to run checks. The values required for this parameter can be retrieved from the &#x60;GET /v1/uptime-locations&#x60; endpoint.
   * @param {string} [statusCodesCsv] Comma separated list of status codes that trigger an alert
   * @param {Array<string>} [tags] List of tags
   * @param {number} [timeout] The number of seconds to wait to receive the first byte
   * @param {number} [triggerRate] The number of minutes to wait before sending an alert
   * @param {boolean} [useJar] Whether to enable cookie storage
   * @param {string} [userAgent] Custom user agent string set when testing
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UptimeApiInterface
   */
  updateUptimeTestRaw(
    requestParameters: UpdateUptimeTestRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>>;

  /**
   * Updates an uptime check with the given parameters.
   * Update an uptime check
   */
  updateUptimeTest(
    requestParameters: UpdateUptimeTestRequest,
    initOverrides?: RequestInit,
  ): Promise<void>;
}

/**
 *
 */
export class UptimeApi extends runtime.BaseAPI implements UptimeApiInterface {
  /**
   * Creates an uptime check with the given parameters.
   * Create an uptime check
   */
  async createUptimeTestRaw(
    requestParameters: CreateUptimeTestRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<APIResponse>> {
    if (
      requestParameters.name === null ||
      requestParameters.name === undefined
    ) {
      throw new runtime.RequiredError(
        'name',
        'Required parameter requestParameters.name was null or undefined when calling createUptimeTest.',
      );
    }

    if (
      requestParameters.testType === null ||
      requestParameters.testType === undefined
    ) {
      throw new runtime.RequiredError(
        'testType',
        'Required parameter requestParameters.testType was null or undefined when calling createUptimeTest.',
      );
    }

    if (
      requestParameters.websiteUrl === null ||
      requestParameters.websiteUrl === undefined
    ) {
      throw new runtime.RequiredError(
        'websiteUrl',
        'Required parameter requestParameters.websiteUrl was null or undefined when calling createUptimeTest.',
      );
    }

    if (
      requestParameters.checkRate === null ||
      requestParameters.checkRate === undefined
    ) {
      throw new runtime.RequiredError(
        'checkRate',
        'Required parameter requestParameters.checkRate was null or undefined when calling createUptimeTest.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const consumes: runtime.Consume[] = [
      { contentType: 'application/x-www-form-urlencoded' },
    ];
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes);

    let formParams: { append(param: string, value: any): any };
    let useForm = false;
    if (useForm) {
      formParams = new FormData();
    } else {
      formParams = new URLSearchParams();
    }

    if (requestParameters.name !== undefined) {
      formParams.append('name', requestParameters.name as any);
    }

    if (requestParameters.testType !== undefined) {
      formParams.append(
        'test_type',
        new Blob(
          [JSON.stringify(UptimeTestTypeToJSON(requestParameters.testType))],
          { type: 'application/json' },
        ),
      );
    }

    if (requestParameters.websiteUrl !== undefined) {
      formParams.append('website_url', requestParameters.websiteUrl as any);
    }

    if (requestParameters.checkRate !== undefined) {
      formParams.append(
        'check_rate',
        new Blob(
          [
            JSON.stringify(
              UptimeTestCheckRateToJSON(requestParameters.checkRate),
            ),
          ],
          { type: 'application/json' },
        ),
      );
    }

    if (requestParameters.basicUsername !== undefined) {
      formParams.append(
        'basic_username',
        requestParameters.basicUsername as any,
      );
    }

    if (requestParameters.basicPassword !== undefined) {
      formParams.append(
        'basic_password',
        requestParameters.basicPassword as any,
      );
    }

    if (requestParameters.confirmation !== undefined) {
      formParams.append('confirmation', requestParameters.confirmation as any);
    }

    if (requestParameters.contactGroups) {
      formParams.append(
        'contact_groups',
        requestParameters.contactGroups.join(runtime.COLLECTION_FORMATS['csv']),
      );
    }

    if (requestParameters.customHeader !== undefined) {
      formParams.append('custom_header', requestParameters.customHeader as any);
    }

    if (requestParameters.doNotFind !== undefined) {
      formParams.append('do_not_find', requestParameters.doNotFind as any);
    }

    if (requestParameters.dnsIps) {
      formParams.append(
        'dns_ips',
        requestParameters.dnsIps.join(runtime.COLLECTION_FORMATS['csv']),
      );
    }

    if (requestParameters.dnsServer !== undefined) {
      formParams.append('dns_server', requestParameters.dnsServer as any);
    }

    if (requestParameters.enableSslAlert !== undefined) {
      formParams.append(
        'enable_ssl_alert',
        requestParameters.enableSslAlert as any,
      );
    }

    if (requestParameters.finalEndpoint !== undefined) {
      formParams.append(
        'final_endpoint',
        requestParameters.finalEndpoint as any,
      );
    }

    if (requestParameters.findString !== undefined) {
      formParams.append('find_string', requestParameters.findString as any);
    }

    if (requestParameters.followRedirects !== undefined) {
      formParams.append(
        'follow_redirects',
        requestParameters.followRedirects as any,
      );
    }

    if (requestParameters.host !== undefined) {
      formParams.append('host', requestParameters.host as any);
    }

    if (requestParameters.includeHeader !== undefined) {
      formParams.append(
        'include_header',
        requestParameters.includeHeader as any,
      );
    }

    if (requestParameters.paused !== undefined) {
      formParams.append('paused', requestParameters.paused as any);
    }

    if (requestParameters.port !== undefined) {
      formParams.append('port', requestParameters.port as any);
    }

    if (requestParameters.postBody !== undefined) {
      formParams.append('post_body', requestParameters.postBody as any);
    }

    if (requestParameters.postRaw !== undefined) {
      formParams.append('post_raw', requestParameters.postRaw as any);
    }

    if (requestParameters.regions) {
      formParams.append(
        'regions',
        requestParameters.regions.join(runtime.COLLECTION_FORMATS['csv']),
      );
    }

    if (requestParameters.statusCodesCsv !== undefined) {
      formParams.append(
        'status_codes_csv',
        requestParameters.statusCodesCsv as any,
      );
    }

    if (requestParameters.tags) {
      formParams.append(
        'tags',
        requestParameters.tags.join(runtime.COLLECTION_FORMATS['csv']),
      );
    }

    if (requestParameters.timeout !== undefined) {
      formParams.append('timeout', requestParameters.timeout as any);
    }

    if (requestParameters.triggerRate !== undefined) {
      formParams.append('trigger_rate', requestParameters.triggerRate as any);
    }

    if (requestParameters.useJar !== undefined) {
      formParams.append('use_jar', requestParameters.useJar as any);
    }

    if (requestParameters.userAgent !== undefined) {
      formParams.append('user_agent', requestParameters.userAgent as any);
    }

    const response = await this.request(
      {
        path: `/uptime`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: formParams,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      APIResponseFromJSON(jsonValue),
    );
  }

  /**
   * Creates an uptime check with the given parameters.
   * Create an uptime check
   */
  async createUptimeTest(
    requestParameters: CreateUptimeTestRequest,
    initOverrides?: RequestInit,
  ): Promise<APIResponse> {
    const response = await this.createUptimeTestRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Deletes an uptime check with the given id.
   * Delete an uptime check
   */
  async deleteUptimeTestRaw(
    requestParameters: DeleteUptimeTestRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.testId === null ||
      requestParameters.testId === undefined
    ) {
      throw new runtime.RequiredError(
        'testId',
        'Required parameter requestParameters.testId was null or undefined when calling deleteUptimeTest.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/uptime/{test_id}`.replace(
          `{${'test_id'}}`,
          encodeURIComponent(String(requestParameters.testId)),
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Deletes an uptime check with the given id.
   * Delete an uptime check
   */
  async deleteUptimeTest(
    requestParameters: DeleteUptimeTestRequest,
    initOverrides?: RequestInit,
  ): Promise<void> {
    await this.deleteUptimeTestRaw(requestParameters, initOverrides);
  }

  /**
   * Returns an uptime check with the given id.
   * Retrieve an uptime check
   */
  async getUptimeTestRaw(
    requestParameters: GetUptimeTestRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<UptimeTestResponse>> {
    if (
      requestParameters.testId === null ||
      requestParameters.testId === undefined
    ) {
      throw new runtime.RequiredError(
        'testId',
        'Required parameter requestParameters.testId was null or undefined when calling getUptimeTest.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/uptime/{test_id}`.replace(
          `{${'test_id'}}`,
          encodeURIComponent(String(requestParameters.testId)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      UptimeTestResponseFromJSON(jsonValue),
    );
  }

  /**
   * Returns an uptime check with the given id.
   * Retrieve an uptime check
   */
  async getUptimeTest(
    requestParameters: GetUptimeTestRequest,
    initOverrides?: RequestInit,
  ): Promise<UptimeTestResponse> {
    const response = await this.getUptimeTestRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Returns a list of uptime check alerts for a given id.  The returned results are a paginated series. Alongside the response data is a `links` object referencing the current response document, `self`, and the next page in the series, `next`.
   * Get all uptime check alerts
   */
  async listUptimeTestAlertsRaw(
    requestParameters: ListUptimeTestAlertsRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<UptimeTestAlerts>> {
    if (
      requestParameters.testId === null ||
      requestParameters.testId === undefined
    ) {
      throw new runtime.RequiredError(
        'testId',
        'Required parameter requestParameters.testId was null or undefined when calling listUptimeTestAlerts.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.before !== undefined) {
      queryParameters['before'] = requestParameters.before;
    }

    if (requestParameters.after !== undefined) {
      queryParameters['after'] = requestParameters.after;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/uptime/{test_id}/alerts`.replace(
          `{${'test_id'}}`,
          encodeURIComponent(String(requestParameters.testId)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      UptimeTestAlertsFromJSON(jsonValue),
    );
  }

  /**
   * Returns a list of uptime check alerts for a given id.  The returned results are a paginated series. Alongside the response data is a `links` object referencing the current response document, `self`, and the next page in the series, `next`.
   * Get all uptime check alerts
   */
  async listUptimeTestAlerts(
    requestParameters: ListUptimeTestAlertsRequest,
    initOverrides?: RequestInit,
  ): Promise<UptimeTestAlerts> {
    const response = await this.listUptimeTestAlertsRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Returns a list of uptime check history results for a given id, detailing the runs performed on the StatusCake testing infrastruture.  The returned results are a paginated series. Alongside the response data is a `links` object referencing the current response document, `self`, and the next page in the series, `next`.
   * Get all uptime check history
   */
  async listUptimeTestHistoryRaw(
    requestParameters: ListUptimeTestHistoryRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<UptimeTestHistory>> {
    if (
      requestParameters.testId === null ||
      requestParameters.testId === undefined
    ) {
      throw new runtime.RequiredError(
        'testId',
        'Required parameter requestParameters.testId was null or undefined when calling listUptimeTestHistory.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.before !== undefined) {
      queryParameters['before'] = requestParameters.before;
    }

    if (requestParameters.after !== undefined) {
      queryParameters['after'] = requestParameters.after;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/uptime/{test_id}/history`.replace(
          `{${'test_id'}}`,
          encodeURIComponent(String(requestParameters.testId)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      UptimeTestHistoryFromJSON(jsonValue),
    );
  }

  /**
   * Returns a list of uptime check history results for a given id, detailing the runs performed on the StatusCake testing infrastruture.  The returned results are a paginated series. Alongside the response data is a `links` object referencing the current response document, `self`, and the next page in the series, `next`.
   * Get all uptime check history
   */
  async listUptimeTestHistory(
    requestParameters: ListUptimeTestHistoryRequest,
    initOverrides?: RequestInit,
  ): Promise<UptimeTestHistory> {
    const response = await this.listUptimeTestHistoryRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Returns a list of uptime check periods for a given id, detailing the creation time of the period, when it ended and the duration.  The returned results are a paginated series. Alongside the response data is a `links` object referencing the current response document, `self`, and the next page in the series, `next`.
   * Get all uptime check periods
   */
  async listUptimeTestPeriodsRaw(
    requestParameters: ListUptimeTestPeriodsRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<UptimeTestPeriods>> {
    if (
      requestParameters.testId === null ||
      requestParameters.testId === undefined
    ) {
      throw new runtime.RequiredError(
        'testId',
        'Required parameter requestParameters.testId was null or undefined when calling listUptimeTestPeriods.',
      );
    }

    const queryParameters: any = {};

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.before !== undefined) {
      queryParameters['before'] = requestParameters.before;
    }

    if (requestParameters.after !== undefined) {
      queryParameters['after'] = requestParameters.after;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/uptime/{test_id}/periods`.replace(
          `{${'test_id'}}`,
          encodeURIComponent(String(requestParameters.testId)),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      UptimeTestPeriodsFromJSON(jsonValue),
    );
  }

  /**
   * Returns a list of uptime check periods for a given id, detailing the creation time of the period, when it ended and the duration.  The returned results are a paginated series. Alongside the response data is a `links` object referencing the current response document, `self`, and the next page in the series, `next`.
   * Get all uptime check periods
   */
  async listUptimeTestPeriods(
    requestParameters: ListUptimeTestPeriodsRequest,
    initOverrides?: RequestInit,
  ): Promise<UptimeTestPeriods> {
    const response = await this.listUptimeTestPeriodsRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Returns a list of uptime checks for an account.
   * Get all uptime checks
   */
  async listUptimeTestsRaw(
    requestParameters: ListUptimeTestsRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<UptimeTests>> {
    const queryParameters: any = {};

    if (requestParameters.status !== undefined) {
      queryParameters['status'] = requestParameters.status;
    }

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.limit !== undefined) {
      queryParameters['limit'] = requestParameters.limit;
    }

    if (requestParameters.tags !== undefined) {
      queryParameters['tags'] = requestParameters.tags;
    }

    if (requestParameters.matchany !== undefined) {
      queryParameters['matchany'] = requestParameters.matchany;
    }

    if (requestParameters.nouptime !== undefined) {
      queryParameters['nouptime'] = requestParameters.nouptime;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/uptime`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      UptimeTestsFromJSON(jsonValue),
    );
  }

  /**
   * Returns a list of uptime checks for an account.
   * Get all uptime checks
   */
  async listUptimeTests(
    requestParameters: ListUptimeTestsRequest = {},
    initOverrides?: RequestInit,
  ): Promise<UptimeTests> {
    const response = await this.listUptimeTestsRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Updates an uptime check with the given parameters.
   * Update an uptime check
   */
  async updateUptimeTestRaw(
    requestParameters: UpdateUptimeTestRequest,
    initOverrides?: RequestInit,
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.testId === null ||
      requestParameters.testId === undefined
    ) {
      throw new runtime.RequiredError(
        'testId',
        'Required parameter requestParameters.testId was null or undefined when calling updateUptimeTest.',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const consumes: runtime.Consume[] = [
      { contentType: 'application/x-www-form-urlencoded' },
    ];
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes);

    let formParams: { append(param: string, value: any): any };
    let useForm = false;
    if (useForm) {
      formParams = new FormData();
    } else {
      formParams = new URLSearchParams();
    }

    if (requestParameters.name !== undefined) {
      formParams.append('name', requestParameters.name as any);
    }

    if (requestParameters.websiteUrl !== undefined) {
      formParams.append('website_url', requestParameters.websiteUrl as any);
    }

    if (requestParameters.checkRate !== undefined) {
      formParams.append(
        'check_rate',
        new Blob(
          [
            JSON.stringify(
              UptimeTestCheckRateToJSON(requestParameters.checkRate),
            ),
          ],
          { type: 'application/json' },
        ),
      );
    }

    if (requestParameters.basicUsername !== undefined) {
      formParams.append(
        'basic_username',
        requestParameters.basicUsername as any,
      );
    }

    if (requestParameters.basicPassword !== undefined) {
      formParams.append(
        'basic_password',
        requestParameters.basicPassword as any,
      );
    }

    if (requestParameters.confirmation !== undefined) {
      formParams.append('confirmation', requestParameters.confirmation as any);
    }

    if (requestParameters.contactGroups) {
      formParams.append(
        'contact_groups',
        requestParameters.contactGroups.join(runtime.COLLECTION_FORMATS['csv']),
      );
    }

    if (requestParameters.customHeader !== undefined) {
      formParams.append('custom_header', requestParameters.customHeader as any);
    }

    if (requestParameters.doNotFind !== undefined) {
      formParams.append('do_not_find', requestParameters.doNotFind as any);
    }

    if (requestParameters.dnsIps) {
      formParams.append(
        'dns_ips',
        requestParameters.dnsIps.join(runtime.COLLECTION_FORMATS['csv']),
      );
    }

    if (requestParameters.dnsServer !== undefined) {
      formParams.append('dns_server', requestParameters.dnsServer as any);
    }

    if (requestParameters.enableSslAlert !== undefined) {
      formParams.append(
        'enable_ssl_alert',
        requestParameters.enableSslAlert as any,
      );
    }

    if (requestParameters.finalEndpoint !== undefined) {
      formParams.append(
        'final_endpoint',
        requestParameters.finalEndpoint as any,
      );
    }

    if (requestParameters.findString !== undefined) {
      formParams.append('find_string', requestParameters.findString as any);
    }

    if (requestParameters.followRedirects !== undefined) {
      formParams.append(
        'follow_redirects',
        requestParameters.followRedirects as any,
      );
    }

    if (requestParameters.host !== undefined) {
      formParams.append('host', requestParameters.host as any);
    }

    if (requestParameters.includeHeader !== undefined) {
      formParams.append(
        'include_header',
        requestParameters.includeHeader as any,
      );
    }

    if (requestParameters.paused !== undefined) {
      formParams.append('paused', requestParameters.paused as any);
    }

    if (requestParameters.port !== undefined) {
      formParams.append('port', requestParameters.port as any);
    }

    if (requestParameters.postBody !== undefined) {
      formParams.append('post_body', requestParameters.postBody as any);
    }

    if (requestParameters.postRaw !== undefined) {
      formParams.append('post_raw', requestParameters.postRaw as any);
    }

    if (requestParameters.regions) {
      formParams.append(
        'regions',
        requestParameters.regions.join(runtime.COLLECTION_FORMATS['csv']),
      );
    }

    if (requestParameters.statusCodesCsv !== undefined) {
      formParams.append(
        'status_codes_csv',
        requestParameters.statusCodesCsv as any,
      );
    }

    if (requestParameters.tags) {
      formParams.append(
        'tags',
        requestParameters.tags.join(runtime.COLLECTION_FORMATS['csv']),
      );
    }

    if (requestParameters.timeout !== undefined) {
      formParams.append('timeout', requestParameters.timeout as any);
    }

    if (requestParameters.triggerRate !== undefined) {
      formParams.append('trigger_rate', requestParameters.triggerRate as any);
    }

    if (requestParameters.useJar !== undefined) {
      formParams.append('use_jar', requestParameters.useJar as any);
    }

    if (requestParameters.userAgent !== undefined) {
      formParams.append('user_agent', requestParameters.userAgent as any);
    }

    const response = await this.request(
      {
        path: `/uptime/{test_id}`.replace(
          `{${'test_id'}}`,
          encodeURIComponent(String(requestParameters.testId)),
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: formParams,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Updates an uptime check with the given parameters.
   * Update an uptime check
   */
  async updateUptimeTest(
    requestParameters: UpdateUptimeTestRequest,
    initOverrides?: RequestInit,
  ): Promise<void> {
    await this.updateUptimeTestRaw(requestParameters, initOverrides);
  }
}

/**
 * @export
 * @enum {string}
 */
export enum ListUptimeTestsStatusEnum {
  Down = 'down',
  Up = 'up',
}
